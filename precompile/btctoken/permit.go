package btctoken

import (
	"bytes"
	// "encoding/hex"
	"fmt"
	"math/big"
	"time"

	sdk "github.com/cosmos/cosmos-sdk/types"
	authzkeeper "github.com/cosmos/cosmos-sdk/x/authz/keeper"
	bankkeeper "github.com/cosmos/cosmos-sdk/x/bank/keeper"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/evmos/evmos/v12/precompile"
	evmkeeper "github.com/evmos/evmos/v12/x/evm/keeper"
	evmtypes "github.com/evmos/evmos/v12/x/evm/types"
)

// PermitMethodName is the name of the permit method that should match the name
// in the contract ABI.
const (
	PermitMethodName = "permit"
	PermitTypehash   = "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
	// DomainSeparator was generated by combination of encoding and hashing different
	// params ilustrated in the pseudo code below. The actual implementation in GO that
	// produced this hash can be found in tests which results in the same output as
	// it was written on EVM in Solidity.
	// Here we can use just the hardcoded output value.
	//
	// keccak256(encode(
	//						keccak256(
	//							"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
	//						),
	//						keccak256(BTC),
	//						keccak256(1),
	//						31612,
	//						0x7b7C000000000000000000000000000000000000
	//					)
	//	)
	DomainSeparator = "f98315225d67e6d98b18f0a6b73bf711423ff8310bd350400db36e876c5cddf4"
)

// Sets a `value` amount of tokens as the allowance of `spender` over the
// caller's tokens.
type permitMethod struct {
	bankKeeper  bankkeeper.Keeper
	authzkeeper authzkeeper.Keeper
	evmkeeper   evmkeeper.Keeper
}

func newPermitMethod(
	bankKeeper bankkeeper.Keeper,
	authzkeeper authzkeeper.Keeper,
	evmkeeper evmkeeper.Keeper,
) *permitMethod {
	return &permitMethod{
		bankKeeper:  bankKeeper,
		authzkeeper: authzkeeper,
		evmkeeper:   evmkeeper,
	}
}

func (am *permitMethod) MethodName() string {
	return PermitMethodName
}

func (am *permitMethod) MethodType() precompile.MethodType {
	return precompile.Write
}

func (am *permitMethod) RequiredGas(_ []byte) (uint64, bool) {
	// Fallback to the default gas calculation.
	return 0, false
}

func (am *permitMethod) Payable() bool {
	return false
}

// EIP2612 approval made with secp256k1 signature.
// Users can authorize a transfer of their tokens with a signature
// conforming EIP712 standard, rather than an on-chain transaction
// from their address. Anyone can submit this signature on the
// user's behalf by calling the permit function, paying gas fees,
// and possibly performing other actions in the same transaction.
func (am *permitMethod) Run(
	context *precompile.RunContext,
	inputs precompile.MethodInputs,
) (precompile.MethodOutputs, error) {
	timestamp := time.Now().Unix() // Now

	// For testing purposes only
	fmt.Println("yooo Domain Separator:")

	if err := precompile.ValidateMethodInputsCount(inputs, 7); err != nil {
		return nil, err
	}

	owner, ok := inputs[0].(common.Address)
	if !ok {
		return nil, fmt.Errorf("invalid owner address: %v", inputs[0])
	}
	if isZeroAddress(owner) {
		return nil, fmt.Errorf("owner address cannot be empty")
	}

	spender, ok := inputs[1].(common.Address)
	if !ok {
		return nil, fmt.Errorf("invalid spender address: %v", inputs[1])
	}
	if isZeroAddress(spender) {
		return nil, fmt.Errorf("spender address cannot be empty")
	}

	amount, ok := inputs[2].(*big.Int)
	if !ok {
		return nil, fmt.Errorf("invalid amount: %v", inputs[2])
	}
	if amount == nil || amount.Sign() < 0 {
		amount = big.NewInt(0)
	}

	deadline, ok := inputs[3].(*big.Int)
	if !ok {
		return nil, fmt.Errorf("invalid deadline: %v", inputs[3])
	}
	// Check if deadline has passed
	if deadline.Int64() < timestamp {
		return nil, fmt.Errorf("permit expired")
	}

	v, ok := inputs[4].(byte)
	if !ok {
		return nil, fmt.Errorf("invalid v value: %v", inputs[4])
	}
	if v != 27 && v != 28 {
		return nil, fmt.Errorf("invalid v value: %v", v)
	}
	// Only signatures `v` value of 27 or 28 are considered valid, however
	// ValidateSignatureValues assumes that the `v` value is already adjusted and
	// expects it to be 0 or 1.
	v = v - 27

	r_component, ok := inputs[5].([32]byte)
	if !ok {
		return nil, fmt.Errorf("invalid r component of the signature: %v", inputs[5])
	}
	r := new(big.Int).SetBytes(r_component[:])

	s_component, ok := inputs[6].([32]byte)
	if !ok {
		return nil, fmt.Errorf("invalid s component of the signature: %v", inputs[6])
	}
	s := new(big.Int).SetBytes(s_component[:])
	
	// A boolean set to true checks the signature with `s` value against the lower
	// half of the secp256k1 curve's order and is considered valid.
	if !crypto.ValidateSignatureValues(v, r, s, true) {
		return nil, fmt.Errorf("invalid signature values")
	}

	// TODO: remove
	fmt.Println("Passed the sig validation")

	// Solidity code for reference:
	// 	keccak256(
	// 		abi.encode(
	// 				PERMIT_TYPEHASH,
	// 				owner,
	// 				spender,
	// 				amount,
	// 				nonce[owner]++,
	// 				deadline
	// 		)
	// 	)

	// TODO: There's a problem with nonce, check it.
	// nonce, err := am.getNonce(owner, context.SdkCtx())
	// if err != nil {
	// 	return nil, err
	// }

	bytes32Type, err := abi.NewType("bytes32", "", nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create new type: %v", err)
	}
	// addressType, err := abi.NewType("address", "", nil)
	// if err != nil {
	// 	return nil, fmt.Errorf("failed to create new type: %v", err)
	// }
	// uint256Type, err := abi.NewType("uint256", "", nil)
	// if err != nil {
	// 	return nil, fmt.Errorf("failed to create new type: %v", err)
	// }

	var PermitTypehashBytes32 [32]byte
	// Convert to bytes32 (32-byte array)
	copy(PermitTypehashBytes32[:], crypto.Keccak256([]byte(PermitTypehash))[:32])

	// Encode the permit parameters
	// encodedPermitParams, err := abi.Arguments{
	// 	{Type: bytes32Type},
	// 	{Type: addressType},
	// 	{Type: addressType},
	// 	{Type: uint256Type},
	// 	{Type: uint256Type},
	// 	{Type: uint256Type},
	// }.Pack(
	// 	PermitTypehashBytes32, // done.
	// 	owner,
	// 	spender,
	// 	amount,
	// 	nonce,
	// 	deadline,
	// )

	// Encode the permit parameters
	encodedPermitParams, err := abi.Arguments{
		{Type: bytes32Type},
	}.Pack(
		PermitTypehashBytes32,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to encode permit parameters: %v", err)
	}

	encodedPermitParamsHashed := crypto.Keccak256(encodedPermitParams)

	// A message should consist of:
	// - The EIP712 Domain Separator (name, version, chainId, this precompile address, salt). See: https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator
	// - The Permit struct that includes: permit_typehash, owner, spender, value, nonce?, deadline. See: https://eips.ethereum.org/EIPS/eip-2612#specification
	// - The hash of the message

	// 	abi.encodePacked(
	// 		"\x19\x01",
	// 		DOMAIN_SEPARATOR(),
	// 		encodedPermitParamsHashed
	// )
	// Encode the prefix, domain separator, and hashed permit parameters
	// domainSeparator, _ := hex.DecodeString(DomainSeparator)
	// encodedData := append([]byte("\x19\x01"), domainSeparator...)
	// encodedData = append(encodedData, encodedPermitParamsHashed...)
	encodedData := append([]byte(""), encodedPermitParamsHashed...)

	digest := crypto.Keccak256(encodedData)

	// Concatenate r, s, and v to form the full signature
	signature := append(r.Bytes(), s.Bytes()...)
	signature = append(signature, v)

	// Recover the public key from the signature
	recoveredPubKey, err := crypto.SigToPub(digest, signature)
	if err != nil {
		return nil, fmt.Errorf("failed to recover public key from signature: %v", err)
	}

	// The recovered pub key is verified to ensure that the owner has signed the message.
	if !bytes.Equal(crypto.PubkeyToAddress(*recoveredPubKey).Bytes(), owner.Bytes()) {
		return nil, fmt.Errorf("signature verification failed")
	}

	approveMethod := newApproveMethod(am.bankKeeper, am.authzkeeper)
	authorization, expiration := am.authzkeeper.GetAuthorization(context.SdkCtx(), spender.Bytes(), owner.Bytes(), SendMsgURL)

	if authorization == nil {
		if amount.Sign() == 0 {
			// no authorization, amount 0 -> error
			err = fmt.Errorf("no existing approvals, cannot approve 0")
		} else {
			// no authorization, amount positive -> create a new authorization
			err = approveMethod.createAuthorization(context.SdkCtx(), spender, owner, amount)
		}
	} else {
		if amount.Sign() == 0 {
			// authorization exists, amount 0 -> delete authorization
			err = am.authzkeeper.DeleteGrant(context.SdkCtx(), spender.Bytes(), owner.Bytes(), SendMsgURL)
		} else {
			// authorization exists, amount positive -> update authorization
			err = approveMethod.updateAuthorization(context.SdkCtx(), spender, owner, amount, authorization, expiration)
		}
	}

	if err != nil {
		return nil, err
	}

	err = am.setNonce(owner, context.SdkCtx())
	if err != nil {
		return nil, fmt.Errorf("failed to set nonce: %w", err)
	}

	err = context.EventEmitter().Emit(
		NewApprovalEvent(
			owner,
			spender,
			amount,
		),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to emit approval event: [%w]", err)
	}

	return precompile.MethodOutputs{true}, nil
}

func (am *permitMethod) getNonce(address common.Address, ctx sdk.Context) (common.Hash, error) {
	key := evmtypes.PrecompileBTCNonceKey(address)
	nonce := am.evmkeeper.GetState(ctx, address, common.HexToHash(string(key)))
	if len(nonce) == 0 {
		return common.Hash{}, fmt.Errorf("failed to get nonce for address %s", address.Hex())
	}
	return nonce, nil
}

func (am *permitMethod) setNonce(address common.Address, ctx sdk.Context) error {
	key := evmtypes.PrecompileBTCNonceKey(address)
	nonce, err := am.getNonce(address, ctx)
	if err != nil {
		return fmt.Errorf("failed to get nonce: %w", err)
	}
	// Increment nonce by 1 so that the signature can be used once over the message
	nonce.Big().Add(nonce.Big(), big.NewInt(1))
	am.evmkeeper.SetState(ctx, address, common.HexToHash(string(key)), nonce.Bytes())
	return nil
}

// TODO: Add GetNonce as a new method so the users can get the nonce value
